[ { "title": "从装系统到配置深度学习环境（PCDet）", "url": "/posts/%E4%BB%8E%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%88%B0%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83-PCDet/", "categories": "点云3D目标检测", "tags": "环境配置", "date": "2021-05-30 23:32:05 +0800", "snippet": " 最终环境配置如下 显卡：NVIDIA RTX 2070;操作系统：Ubuntu18.04;pytorch 1.8.0;Python 3.7.10; cuda 11.0; cudnn 8.0.5; cmake 3.16.3; g++ 7.5------以下是PCdet基本环境-----spconv 1.2.1pcdet 0.3.0 1. 装Ubuntu18.04操作系统 下载Ubuntu 镜像 制作U盘启动盘 工具：Rufus 具体操作参考 安装（选择最简安装速度快很多） 配置一些基本软件 ..." }, { "title": "分类器性能评价指标", "url": "/posts/%E5%88%86%E7%B1%BB%E5%99%A8%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/", "categories": "机器学习", "tags": "评价指标", "date": "2021-03-22 12:53:05 +0800", "snippet": "通用指标1. 混淆矩阵confusion matrix TP(truth positive)：本身（真实情况）是阳性，检测（决策）出来也是阳性 FP(false positive)：本身是阴性，检测出来是阳性 TN(truth negative)：本身是阴性，检测出来也是阴性 FN(false negative)：本身是阳性，但检测出来是阴性 【理解记忆：false代表的是错误的决策，negative代表的是决策的结果；因此命名规则为 决策的正确性+决策的结果】 2. 召回率、准确率 FPR （False Positi..." }, { "title": "从伯努利实验到概率分布", "url": "/posts/%E4%BB%8E%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%AE%9E%E9%AA%8C%E5%88%B0%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/", "categories": "数学", "tags": "概率分布", "date": "2021-03-07 21:35:00 +0800", "snippet": "0. 基础知识 什么是分布distribution？全称概率分布，也叫分布律、概率函数，用来表述随机变量取值的概率规律，也就是数据在统计图中的形状，也就是随机变量X取某个值的概率P是多少 什么是分布函数？由分布的定义我们可以知道，概率P是随机变量X的函数，因此我们定义 分布函数F(x)，是指随机变量X小于x时的概率之和，即F(x) = P(X&amp;lt;=x) 由于数据有离散型和连续型两种类型，所以随机变量的概率分布 分为 离散型随机变量的概率分布 和 连续型随机变量的概率分布 对于离散型随机变量X，X的取值为可列多个，离散型变量分布函数为阶梯函数，常见的离散型随机变量的概率..." }, { "title": "《事实》读后感", "url": "/posts/%E4%BA%8B%E5%AE%9E-%E4%B9%A6%E6%91%98/", "categories": "阅读", "tags": "读后感, 书摘", "date": "2021-01-24 13:25:00 +0800", "snippet": " 事实 Factfulness；作者：[瑞典]汉斯·罗斯林一分为二【问题】人们似乎总是喜欢把事物一分为二为两个类别，而这两个类别又是互相对立、互相矛盾的，并且这两个类别之间存在着一道巨大的鸿沟。这种一分为二的本能会误导我们，把平滑过渡当作两极分化，把和而不同当作分道扬镳，把求同存异当作矛盾对立。【解决】我们应该看到数据背后代表的是什么，坚持寻找绝大多数。许多媒体报道的数据都喜欢用极端的数据去吸引眼球，引起大家的情绪从而丧失看清事实的能力。所以每当我们看到一个平均数，极值的时候，我们就应该本能地想到，它的背后代表某一种数据的分布。作者在这本书中指出将世界分为发展中国家和发达国家是不准确的..." }, { "title": "网页设计并部署到服务器", "url": "/posts/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/", "categories": "网页开发", "tags": "php, 服务器", "date": "2020-10-20 10:00:00 +0800", "snippet": "服务器的购买与配置 购买服务器 阿里云服务器（学生9.5一个月） 推荐centos 7版本 开放服务器端口 查看IP [due on 2021.1.14] 开放端口（数据库3306；ssh22；http协议默认80端口；宝塔linux8888） 本机与服务器通信工具 SSH工具（连接同一个端口22） 命令行操控服务器：Final Shell 传输文件：Filezilla 宝塔linux面板（可选） 安装步骤简而言之如下：【教程见https://y..." }, { "title": "分类与聚类模型整理", "url": "/posts/%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B%E6%95%B4%E7%90%86/", "categories": "数学建模", "tags": "数学建模, 聚类", "date": "2020-09-04 14:07:00 +0800", "snippet": "分类模型整理1、SVM SVM算法特点与介绍 训练好的模型的算法复杂度是由支持向量的个数决定的，而不是由数据的维度决定的。所以 SVM 不太容易产生 overfitting。 SVM 训练出来的模型完全依赖于支持向量，即使训练集里面所有非支持向量的点都被去除，重复训练过程，结果仍然会得到完全一样的模型。 一个 SVM 如果训练得出的支持向量个数比较少，那么SVM 训练出的模型比较容易被泛化。 优点：SVM在中小量样本规模的时候容易得到数据和特征之间的非线性关系，可以避免使用神经网..." }, { "title": "回溯法", "url": "/posts/%E5%9B%9E%E6%BA%AF%E6%B3%95/", "categories": "算法笔记, 算法学习", "tags": "回溯法", "date": "2020-05-20 15:33:00 +0800", "snippet": "1、基本概念与关键理解（1）回溯法在问题的解空间树中,按深度优先策略,从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时,先判断该结点是否包含问题的解。如果肯定不包含,则跳过对该结点为根的子树的搜索,逐层向其祖先结点回溯;否则,进入该子树,继续按深度优先策略搜索。（2）回溯法的基本做法是搜索：或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。搜索是算法设计的一大核心，搜索最简单的做法就是穷举。分治法、动态规划、回溯法、分支限界法等等都可以看作对穷举的“优化”，这些算法本质上都是在考虑如何有“规律”的组织每一次“随机”。（3）问题的解向量：回溯法希望一个问题的解能够表示成一个..." }, { "title": "从矩阵连乘计算次序问题引出动态规划", "url": "/posts/%E4%BB%8E%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E8%AE%A1%E7%AE%97%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/", "categories": "算法笔记, 动态规划", "tags": "矩阵连乘", "date": "2020-04-09 14:33:00 +0800", "snippet": "1. 问题描述：　　给定n个矩阵：A1,A2,…,An，其中Ai与Ai+1是可乘的，i=1,2,…,n-1。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的乘法（数乘）次数最少。　　例如：有四个矩阵A：50x10；B：10x40；C：40x30；D：30x50，总共有五种加括号的方式：(A((BC)D))， (A(B(CD)))， ((AB)(CD))， (((AB)C)D)， ((A(BC))D)，所需乘运算的次数分别为16000，10500，36000，87500，34500，因此，计算矩阵连乘积需要乘法次数最少的方式是(A(B(CD)))2. 思路引导：（根据SCU左..." }, { "title": "Google Colab 使用易错总结", "url": "/posts/Google-Colab-%E4%BD%BF%E7%94%A8%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/", "categories": "工具", "tags": "Google", "date": "2020-04-05 10:44:00 +0800", "snippet": "Google Colab 使用易错总结正常步骤以SiamFC++为例注意点1.一定要注意先选取运行环境！！！否则后面的工作白做2.在colab中使用命令需要注意对空格的转义!python /content/drive/My\\ Drive/BertNer/BERT_NER.py 3.colab运行目录是/content/drive/My Drive要特别注意当前工作目录，使用以下命令进入当前目录%cd /content/gdrive/My\\ Drive/yourfilename4.如何在colab上更改tensorflow版本查看当前版本!pip3 show tensorflow方法一：如..." }, { "title": "最短距离点对问题（几何中的分治法）", "url": "/posts/%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98-%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%B3%95/", "categories": "算法笔记, 算法学习", "tags": "分治法", "date": "2020-04-04 00:25:00 +0800", "snippet": "一维：算法步骤1.找出点集的中位数m（最大的数和最小的数的平均值）；2.将点集分为小于m的数和大于m的数；3.左边和右边分别递归求得左边的最小值d1、右边的最小值d2；4.记录左边的最大值和右边的最小值，两者之差绝对值为d3；5.返回d1,d2,d3三者最小值。时间复杂度分治法时间复杂度 T(n) = 2T(n/2) + O(n)；因此时间复杂度为O(nlogn).代码实现#include&amp;lt;stdio.h&amp;gt;const int MAXN = 1000000;double dot[MAXN];double min3(double a,double b,double..." }, { "title": "运筹学线性规划问题相关算法matlab代码实现", "url": "/posts/%E8%BF%90%E7%AD%B9%E5%AD%A6%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95matlab%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/", "categories": "算法笔记", "tags": "算法学习", "date": "2020-03-22 20:04:00 +0800", "snippet": " 涉及到的算法有：单纯形法、对偶单纯形法、指派问题的匈牙利算法1. 单纯形法Simplex.mfunction Simplex(A,b,c) [m,n] = size(A); %B = A(1:m,n-m+1:n); %det(B)!=0 sigma = c - c(n-m+1:n)*A b base = [n-m+1:n] while max(sigma) &amp;gt; 0 [t,indexin] = max(sigma); %indexin = basis var to push in theta = b(1:m)./A(1:m,..." }, { "title": "字符串匹配问题", "url": "/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/", "categories": "算法笔记, 算法学习", "tags": "RK算法, KMP算法", "date": "2020-03-06 23:34:00 +0800", "snippet": "算法1：RK算法算法描述：（1）计算模式串的Hashcode方式1：按位相加；方式2：看成26进制数转化为十进制，如abc = 1x26^2 + 2x26^1 + 4x26^0；方式2缺点：字符串很长时，对应的十进制数会非常大（2）主串采用增量计算例如：主串：abbcefg；模式串bce第一次计算abb，第二次计算bbc时：新Hahcode = 旧Hashcode - ‘a’ + ‘c’（3）检查 Hash Collision//20200306#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&a..." }, { "title": "大整数四则运算", "url": "/posts/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/", "categories": "算法笔记, 数学问题", "tags": "大整数运算", "date": "2020-02-12 11:38:20 +0800", "snippet": "大整数加减乘法//20200212#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAXN = 1000;struct bignum{ int d[MAXN]; int len; bignum(){ memset(d,0,sizeof(d)); len = 0; } bignum(char *t){ len = strl..." }, { "title": "树的静态写法", "url": "/posts/%E6%A0%91%E7%9A%84%E9%9D%99%E6%80%81%E5%86%99%E6%B3%95/", "categories": "算法笔记, 数据结构的增删改查", "tags": "树的静态写法", "date": "2020-02-12 11:38:00 +0800", "snippet": " 《算法笔记》P302PAT A1053 Path of Equal Weight //20200211//PAT A1053 Path of Equal Weight #include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAXN = 105;int n,internode,findweight;struct Node{ in..." }, { "title": "数学问题", "url": "/posts/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/", "categories": "算法笔记, 数学问题", "tags": "欧几里得法", "date": "2020-02-11 15:32:00 +0800", "snippet": "最大公约数gcd 与 最小公倍数lcm欧几里得算法（辗转相除法） gcd(a,b) = gcd(b, a%b)lcm(a,b) = a / gcd(a,b) * bint gcd(int a,int b){ if(b == 0) return a; return gcd(b,a%b);}int lcm(int a,int b){ int t = gcd(a,b); return a/t*b;}质因子分解PAT A1059 Prime Factors #include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&..." }, { "title": "AVL Tree", "url": "/posts/AVL-Tree/", "categories": "算法笔记, 数据结构的增删改查", "tags": "AVL树", "date": "2020-02-11 13:14:00 +0800", "snippet": "《算法笔记》P320//20200211//AVL Tree#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;using namespace std;struct node{ int data; int height; node* left; node* right;};node* newnode(int v){ node* p = new node; p-&amp;gt;data = v; p-&amp;gt;height = 1; p-&amp;gt;left =..." }, { "title": "哈夫曼编码树", "url": "/posts/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%A0%91/", "categories": "算法笔记, 数据结构的增删改查", "tags": "哈夫曼树", "date": "2020-02-10 21:36:00 +0800", "snippet": " 实现将编码转化为字母文本 代码1：（20191207） // Internal nodes and leaf nodes are represented by the same classes(struct)#include&amp;lt;iostream&amp;gt;#include&amp;lt;stdlib.h&amp;gt;#define inf 99999using namespace std;int n;int k;typedef struct Node{ char data; int weight; Node* left; ..." }, { "title": "BST二叉搜索树", "url": "/posts/BST%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/", "categories": "算法笔记, 数据结构的增删改查", "tags": "BST", "date": "2020-02-10 20:08:00 +0800", "snippet": " 二叉搜索树结点的查找、插入、删除1. 循环写法：（20191119）BST build &amp;amp; traverse//20191116//BST build &amp;amp; traverse#include&amp;lt;iostream&amp;gt;#include&amp;lt;stdlib.h&amp;gt;using namespace std;typedef struct BSTNode{ int value; struct BSTNode *left; struct BSTNode *right;}BSTNode; BSTNode *ro..." }, { "title": "最短路径问题", "url": "/posts/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/", "categories": "算法笔记, 图论", "tags": "Dijkstra算法", "date": "2020-02-06 14:20:00 +0800", "snippet": "算法1：使用dfs遍历整个图【邻接矩阵（无向图）】直接用dfs解决（无法输出具体路径）（洛谷OJ时一个数据超时）#include&amp;lt;stdio.h&amp;gt;#define inf 9999999using namespace std;int min = inf;int book[101],e[101][101],n,start,end;void dfs(int cur,int dis){ int j; if(dis&amp;gt;min) { return; } if(cur==end){ if(dis&amp..." }, { "title": "DFS与BFS", "url": "/posts/DFS%E4%B8%8EBFS/", "categories": "算法笔记, 递归与搜索", "tags": "DFS, BFS", "date": "2020-02-05 00:16:00 +0800", "snippet": "图论与dfs：递归实现：（推荐）//20190807#include&amp;lt;stdio.h&amp;gt;#define inf 9999999int book[101],sum,n,e[101][101],start;int data[101],size;void dfs (int cur){ book[cur] = 1; //printf(&quot;%d &quot;,cur); data[size++] = cur; sum++; if(sum==n) return ; for(int i=1;i&amp;lt;=n;i++) ..." }, { "title": "递归与分治", "url": "/posts/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/", "categories": "算法笔记, 递归与搜索", "tags": "递归", "date": "2020-02-03 20:19:00 +0800", "snippet": " 《算法笔记》P112~118笔记如何理解递归？1.不要想着“不停地调用函数”，应用数学归纳法的思想理解。2.注意递归边界3.寻找递归式（把问题分成若干的子问题，分而治之）比如Fibonacci数列，F(n)的两个子问题分别是F(n-1)，F(n-2)；再比如全排列问题，n位数全排列的子问题是n-1位数的全排列；而n皇后问题则是全排列问题的应用。4.综上：写递归函数重点关注递归调用过程和递归边界问题分治问题的模板：divide-and-conquer(P){ 　　if( P &amp;lt;=n0) { //解决小规模问题 　　　　a..." }, { "title": "队列、栈、链表（STL）", "url": "/posts/%E9%98%9F%E5%88%97-%E6%A0%88-%E9%93%BE%E8%A1%A8-STL/", "categories": "算法笔记, 数据结构的增删改查", "tags": "模板", "date": "2020-02-03 12:50:00 +0800", "snippet": "手写动态链表：（《算法笔记》P253也有详细讲解）代码：头结点单链表 20190923#include&amp;lt;stdio.h&amp;gt;#include&amp;lt;stdlib.h&amp;gt; //有头结点单链表搭建（头插法）typedef struct Node{ int value; struct Node *next;}Node;int main(){ //创建头结点 Node *head = (Node*)malloc(sizeof(Node)); head-&amp;gt;value = -1; head-&amp;gt..." }, { "title": "筛数法求素数+回文判断", "url": "/posts/%E7%AD%9B%E6%95%B0%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0+%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/", "categories": "算法笔记, 数学问题", "tags": "素数", "date": "2020-02-02 19:35:00 +0800", "snippet": "1. 素数的定义哪些数是素数？质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数因此，1不是素数，最小的素数是2。判断一个数n是否为素数，看他能否被2~sqrt(n)整除即可，因为一个合数分解成两个数的乘积，必定一个&amp;lt;=sqrt(n)，一个大于2. 筛数法求素数：（时间复杂度：O(nlglgn）基本思路：一个数的n倍都不是素数#include&amp;lt;iostream&amp;gt;using namespace std;int b[10000000];int prime[10000];int count;int main(){ int n; ..." }, { "title": "寻找对称日", "url": "/posts/%E5%AF%BB%E6%89%BE%E5%AF%B9%E7%A7%B0%E6%97%A5/", "categories": "算法笔记, 数学问题", "tags": "闰年", "date": "2020-02-02 19:32:00 +0800", "snippet": "需求：寻找指定时间段的对称日，对称日所在年份为闰年的需做标记指出关键点：　　1.把一年内的所有合法日期以四位数输出（存到数组中）（从1.1到12.31）　　2.判断是否为闰年思路：把所有合法日期转化成四位的字符串；　　把四位的字符串对称扩展成八位，并保存到容器中；　　按年份从小到大对容器排序；　　把前四位转化成年份，用来判断该对称日所在年份是否为闰年代码实现：//20200202//range : start from 10000101 , end with 99991231 （所有能用八位数表示的日期）#include&amp;lt;iostream&amp;gt;#include&a..." }, { "title": "Tarjan算法求有向图强联通分量及其拓展", "url": "/posts/Tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/", "categories": "算法笔记, 图论", "tags": "Tarjan, 强连通分量", "date": "2020-01-31 14:31:00 +0800", "snippet": "Tarjan算法：用于求有向图的强联通分量算法描述：（1）首先介绍一些辅助数组： dfn[ ]：表示这个点在dfs时是第几个被搜索到，与deep配套使用 low[ ]：表示这个点及其子孙结点连的所有点中dfn最小的值，即记录一个点它最大能连通到哪个祖先节点（包括自己） stack&amp;lt;&amp;gt;：表示当前所有可能能构成强连通分量的点 book[ ]：表示一个点是否在stack中 color：表示所有点着色数，即图中强连通分量的个数 col[ ]：表示这个点属于哪个强连通分量中（2）任选一起始点v： （a）初始化前四个数组（dfn[ ] = low[ ] = ..." }, { "title": "最小生成树与判断无向图是否有回路（并查集）", "url": "/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E5%88%A4%E6%96%AD%E6%97%A0%E5%90%91%E5%9B%BE%E6%98%AF%E5%90%A6%E6%9C%89%E5%9B%9E%E8%B7%AF-%E5%B9%B6%E6%9F%A5%E9%9B%86/", "categories": "算法笔记, 图论", "tags": "并查集", "date": "2020-01-31 11:19:00 +0800", "snippet": "一、最小生成树算法：（1）Kruskal算法　　（a）找出权重最小的边　　（b）判断加入该边以后是否会构成回路（并查集），如果不会，将该边加入生成树中　　重复（a）（b），直到生成树中有n-1条边（2）Prim算法　　选一个结点作为起始结点，并将其加入已选结点集合；　　（a）寻找与已选结点集合任一 一个（不能是两个）结点相关联的最小边（也就是这条最小边关联的结点不能都在已选结点集合中，从而保证了加入这条边一定不会构成回路）　　重复（a）直到生成树中有n-1条边　　注意：该算法不用使用并查集判断是否有回路，因为加入的最小边关联的结点不能都在已选结点集合中代码实现：（Prim算法，可AC练习..." }, { "title": "拓扑排序与判断有向图是否有回路", "url": "/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%A4%E6%96%AD%E6%9C%89%E5%90%91%E5%9B%BE%E6%98%AF%E5%90%A6%E6%9C%89%E5%9B%9E%E8%B7%AF/", "categories": "算法笔记, 图论", "tags": "拓扑排序", "date": "2020-01-31 10:44:00 +0800", "snippet": "方式1：基于BFS：采用入度的方式判断是否有回路 定义队列Q，将所有入度为0的结点加入队列 取出队列的首节点，输出，然后删去从它出发的所有边，并令边的另一端结点的入度减1，如果减到了0，就将其加入队列 重复上面一个操作，直到队列为空。 队列为空时，如果入过队列的结点数为N，则拓扑排序成功，图为有向无环图；否则图中有环//create on 20210216//拓扑排序；判断图中是否有环//基于判断结点入度//邻接表存储；模板#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;q..." }, { "title": "寻找第K大的数", "url": "/posts/%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0/", "categories": "算法笔记, 算法学习", "tags": "BFPRT算法", "date": "2020-01-23 17:05:00 +0800", "snippet": "算法1：快速选择算法（quicksort）算法描述：（建立在快速排序的基础上）[1]\\1. Choose an element from the array as pivot, exchange the position of pivot and number at the end of the array.\\2. The pivot can either be the end element or a random chosen element. A random chosen pivot can make the algorithm much possibly run in aver..." }, { "title": "最长子序列和问题", "url": "/posts/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/", "categories": "算法笔记, 数据结构的增删改查", "tags": "最长子序列和", "date": "2020-01-21 16:52:00 +0800", "snippet": "问题描述：算法1：枚举法 算法描述：以2 -3 -4 13 -5 2 -5 -3 12 -9 为例，分别计算以2，-3，-4…，-9开头的所有子序列和，如果新子序列的和大于当前最大值，则用新子序列的和替代当前最大值。最长序列的下标的更新就发生在最大值的更新过程中。 time cost : 枚举左端点和右端点，需要O(n2)的复杂度；根据计算新子序列之和的方式，总复杂度不一样： 　　　　(a) 计算新子序列之和方式为 从新子序列头加到尾，计算复杂度为O(n)，总时间复杂度为O(n3);　　　　(b) 计算新子序列之和方式为 新子序列和 = 旧子序列和 + 新增加的..." } ]
