---
title: 从矩阵连乘计算次序问题引出动态规划
author: Tour
date: 2020-04-09 14:33:00 +0800
categories: [算法笔记, 动态规划]
tags: [矩阵连乘]
math: true
mermaid: true
pin: true
---

### 1. **问题描述**：

　　给定n个矩阵：A1,A2,...,An，其中Ai与Ai+1是可乘的，i=1,2,…,n-1。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的乘法（数乘）次数最少。

　　例如：有四个矩阵A：50x10；B：10x40；C：40x30；D：30x50，总共有五种加括号的方式：(A((BC)D))， (A(B(CD)))， ((AB)(CD))， (((AB)C)D)， ((A(BC))D)，所需乘运算的次数分别为16000，10500，36000，87500，34500，因此，计算矩阵连乘积需要乘法次数最少的方式是(A(B(CD)))

### 2. **思路引导：**（根据SCU左老师课堂笔记整理）

我们约定**C(i，j)表示Ai\*Ai+1\*…\*Aj中数乘次数**；**Pi表示第i个矩阵的行数，根据矩阵乘法相容性原则，$P_{i+1}$表示第i个矩阵的列数（即第i+1个矩阵的行数）**

* （1）对于给定的一个矩阵连乘问题，我们有很多中加括号的“分解”方法，所有的分类方法用数学符号表示为

**C(i，j) = C(i,k) + C(k+1,j)+Pi\*Pk+1\*Pj+1** （k从i（包括）遍历到j（不包括））

对这个公式的理解：

　　a)为什么要加上Pi\*Pk+1\*Pj+1 ？因为我们把C(i，j) 分成C(i,k)和C(k+1,j)两个矩阵后，这两个矩阵还要做一次乘法，那么这次乘法（数乘）次数为多少呢？相当于矩阵乘法AxB，其中A就是 C(i,k)的结果，所以size(A) = [第i个矩阵的行数，第j个矩阵的列数] = [Pi,Pk+1]；同理，size(B) = [Pk+1,Pj+1]，因此AxB需要Pi\*Pk+1*Pj+1 次乘法运算。

　　b)这里我们和分治法做一个比较：分治法中每种“分解”方案得到的结果都一样，而此处显然每种“分解”方案得到的结果不一样，这里的结果指的是乘法运算次数。

* （2）而这么多的分解方案中，我们只需要最优的，所以应该写成C(i，j) =min{C(i,k) + C(k+1,j) +Pi\*Pk+1*Pj+1 ，k>=i && k<j}；

* 还存在一个问题：原问题最优解是否由子问题的最优解构成？因此我们引出**最优子结构性质（无后向性）：原问题的最优解包含着子问题的最优解。**在这个问题中，我们很容易用反证法证明这点。

* 我们发现上面的公式本质上反映着递归算法。但有一个不好的地方：子问题C(m,n)中有的**被重复多次计算**，这样导致计算效率低。这个问题称为**重叠子问题**。
  * 解决办法1：记忆性。增加一个记忆矩阵，将每个子问题的最优解记录下来，后面计算某些问题需要用到这些子问题的结果时直接调用即可。
  * 解决方法2：采用递推的方法。这个时候我们就要分析原问题与子问题之间的关系。我们根据第一步找到的递归式，**自底向上**来计算，这样使得每一步计算的时候，所需要的子问题的结果都在。对于矩阵连乘问题，具体计算过程见下面的※。

* 如果我们还想知道子问题的最优解是由哪个方案得到的（在这个问题中表现为括号怎么分的）？我们需要**记录过程**。具体方法为再加一个记忆矩阵。

**※ 矩阵连乘问题中，自底向上的过程具体是怎么实现的呢？**

由最开始给的递归公式，我们发现，要计算C(i，j)，要先知道C(i,k) 和 C(k+1,j) 的值。为了方便解释，我们把每一个子问题的结果用一张表（如下）来展现。根据C(i,j)所表示的意义，我们知道这张表只有右上角的元素是需要填写的，且主对角线上的元素为0.

| 0    | C(1,2) | C(1,3) | C(1,4) | C(1,5) | C(1,6) | C(1,7) | C(1,8) |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| -    | 0      |        |        |        |        |        | C(2,8) |
| -    | -      | 0      | C(3,4) | C(3,5) | C(3,6) |        | C(3,8) |
| -    | -      | -      | 0      |        | C(4,6) |        | C(4,8) |
| -    | -      | -      | -      | 0      | C(5,6) |        | C(5,8) |
| -    | -      | -      | -      | -      | 0      |        | C(6,8) |
| -    | -      | -      | -      | -      | -      | 0      | C(7,8) |
| -    | -      | -      | -      | -      | -      | -      | 0      |

由于k<j，所以我们先要知道表中某个点左边的子问题的解；由于k+1>i，所以我们要先知道某个点下边子问题的解。

因此，递推方式1：从C(7,8)开始，从左往右、从下往上计算。例如顺序C(7,8)-->C(6,7)-->C(6,8)-->C(5,6)-->C(5,7)-->.......-->C(1,8);

递推方式2：从紧贴着主对角线的那一条斜线开始，往右上遍历。例如计算顺序C(7,8)-->C(6,7)-->C(5,6)-->......-->C(1,2) -->c(6,8)-->C(5,7)-->C(4,6)-->......-->C(2,8)-->C(1,7)-->C(1,8).

（注意，从C(1,2)开始以这种方式遍历也行，如代码中就是这种方式）

 

### 3. **总结（动态规划的基本步骤）**

* 找出最优解的性质，并刻画其结构特征（即用子问题的最优解表示原问题的最优解）

* 递归地定义最优值

* 以自底向上的方式计算出最优值

* 根据计算最优值时得到的信息，构造最优解。

 

### 4. **代码实现（MATLAB）**

```
function [C,Reck] = Matr(A1,A2,A3,A4,A5,A6,A7,A8)
    para = 8;
    [p(1),col] = size(A1); 
    [p(2),col] = size(A2); 
    [p(3),col] = size(A3); 
    [p(4),col] = size(A4); 
    [p(5),col] = size(A5); 
    [p(6),col] = size(A6); 
    [p(7),col] = size(A7); 
    [p(8),p(9)] = size(A8); %p(i)数组储存矩阵Ai的行数

    for i=1:para
        for j=1:para
            if i==j
                C(i,j) = 0;
            else C(i,j) = Inf;
            end
        end
    end %初始化上面这张表
    Reck = zeros(para,para) %s表示子问题的最优解
    for dif = 1:para-1 %j-i = 1 : para-1
        for i = 1:para-dif
            j = i+dif;
            for k = i:j-1
                temp = C(i,k)+C(k+1,j)+p(i)*p(k+1)*p(j+1);%i,j与C(i,j)意义保持一致
                if temp < C(i,j)
                    C(i,j) = temp;
                    Reck(i,j) = k;
                end
            end
        end
    end
```

main函数测试数据

```
A1 = rand(50,10);
A2 = rand(10,40);
A3 = rand(40,30);
A4 = rand(30,5);
A5 = rand(5,25);
A6 = rand(25,60);
A7 = rand(60,40);
A8 = rand(40,50);
[C,Reck] = Matr(A1,A2,A3,A4,A5,A6,A7,A8)
```

